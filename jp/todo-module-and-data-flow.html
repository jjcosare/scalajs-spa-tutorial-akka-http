
<!DOCTYPE HTML>
<html lang="jp" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Todo module and data flow Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="autowire-and-boopickle.html" />
    
    
    <link rel="prev" href="integrating-javascript-components.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="getting-started.html">
            
                <a href="getting-started.html">
            
                    
                    Getting started
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="application-structure.html">
            
                <a href="application-structure.html">
            
                    
                    Application structure
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="the-client.html">
            
                <a href="the-client.html">
            
                    
                    The Client
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1.1" data-path="routing.html">
            
                <a href="routing.html">
            
                    
                    Routing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.2" data-path="main-menu.html">
            
                <a href="main-menu.html">
            
                    
                    Main menu
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.3" data-path="dashboard.html">
            
                <a href="dashboard.html">
            
                    
                    Dashboard
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.4" data-path="css-in-scala.html">
            
                <a href="css-in-scala.html">
            
                    
                    CSS in Scala
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.5" data-path="integrating-javascript-components.html">
            
                <a href="integrating-javascript-components.html">
            
                    
                    Integrating JavaScript components
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.3.1.6" data-path="todo-module-and-data-flow.html">
            
                <a href="todo-module-and-data-flow.html">
            
                    
                    Todo module and data flow
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.7" data-path="autowire-and-boopickle.html">
            
                <a href="autowire-and-boopickle.html">
            
                    
                    Autowire and BooPickle
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="server-side.html">
            
                <a href="server-side.html">
            
                    
                    Server side
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="testing.html">
            
                <a href="testing.html">
            
                    
                    Testing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="debugging.html">
            
                <a href="debugging.html">
            
                    
                    Debugging
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="logging.html">
            
                <a href="logging.html">
            
                    
                    Logging
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="sbt-build-definition.html">
            
                <a href="sbt-build-definition.html">
            
                    
                    SBT build definition
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="using-resources-from-webjars.html">
            
                <a href="using-resources-from-webjars.html">
            
                    
                    Using resources from WebJars
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.2" data-path="production-build.html">
            
                <a href="production-build.html">
            
                    
                    Production build
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="faq.html">
            
                <a href="faq.html">
            
                    
                    FAQ
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="what-next.html">
            
                <a href="what-next.html">
            
                    
                    What next?
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >Todo module and data flow</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="todo-module-and-data-flow">Todo module and data flow</h1>
<p>The Todo module and its React component are a bit more interesting than Dashboard as they provide some interaction. The module contains a <code>TodoList</code>
component, displaying a list of Todo items retrieved from the server. User can then click the checkbox next to the item to indicate if that item
is completed or not. Internally the state of Todo items is maintained by the <code>Todo</code> module and <code>TodoList</code> just passively displays them.</p>
<p>Before going into the details of the actual Todo module and related components, let&apos;s ponder a while about data flow in a Scala.js React application.</p>
<h2 id="unidirectional-data-flow">Unidirectional data flow</h2>
<p>Several JS frameworks out there (for example AngularJS) use mutable state and two-way data binding. In this tutorial, however, we are using
<a href="https://github.com/ochrons/diode" target="_blank">Diode</a>, which is a library for unidirectional data flow and immutable state. This kind of architecture works especially well
in more complex applications, where two-way data binding can quickly lead to all kinds of hard issues. It&apos;s also a relatively simple concept, so it works well
even in a simple tutorial application like this. Below you can see a diagram of the Diode architecture.</p>
<p><img src="https://github.com/ochrons/diode/raw/master/doc/images/architecture.png" alt="Diode architecture"></p>
<p>It consists of a <em>Circuit</em> that takes in <em>Actions</em>, and dispatches them to action handlers, and then informs <em>Views</em> to update themselves with the new data. See
the <a href="https://ochrons.github.io/diode" target="_blank">Diode documentation</a> for more information.</p>
<h2 id="modifying-a-todo-state">Modifying a Todo state</h2>
<p>The <code>TodoList</code> component renders a checkbox for each Todo, which can be used to mark the Todo as <em>completed</em>.</p>
<pre><code class="lang-scala">&lt;.input.checkbox(^.checked := item.completed, 
  ^.onChange --&gt; <span class="hljs-type">P</span>.stateChange(item.copy(completed = !item.completed))),
</code></pre>
<p>Clicking the checkbox calls the <code>stateChange</code> method, which dispatches an <code>UpdateTodo(item)</code> action to action handler in <code>SPACircuit</code>. In the circuit the action
is picked up by <code>TodoHandler</code>&apos;s <code>handle</code> function, which updates the internal model with the new item and sends it to the server. </p>
<pre><code class="lang-scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoHandler</span>[<span class="hljs-type">M</span>](<span class="hljs-params">modelRW: <span class="hljs-type">ModelRW</span>[<span class="hljs-type">M</span>, <span class="hljs-type">Pot</span>[<span class="hljs-type">Todos</span>]]</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">ActionHandler</span>(<span class="hljs-params">modelRW</span>) </span>{
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handle</span> </span>= {
    <span class="hljs-keyword">case</span> <span class="hljs-type">UpdateTodo</span>(item) =&gt;
      <span class="hljs-keyword">val</span> updateServer = () =&gt; <span class="hljs-type">AjaxClient</span>[<span class="hljs-type">Api</span>].updateTodo(item).call().map(<span class="hljs-type">UpdateAllTodos</span>)
      <span class="hljs-comment">// make a local update and inform server</span>
      update(value.map(_.updated(item)), updateServer)
</code></pre>
<p>Once the server responds, the model is again updated with the data coming from the server. The update happens indirectly by dispatching an <code>UpdateAllTodos</code>
action, which is handled within the same <code>TodoHandler</code>.</p>
<pre><code class="lang-scala">    <span class="hljs-keyword">case</span> <span class="hljs-type">UpdateAllTodos</span>(todos) =&gt;
      <span class="hljs-comment">// got new todos, update model</span>
      update(<span class="hljs-type">Ready</span>(<span class="hljs-type">Todos</span>(todos)))
</code></pre>
<p>The model update triggers calls to change listeners. As it happens, there are actually two separate components observing changes in the <code>Todos</code>. The components
themselves are not actually listening to these changes, but they are wrapped in a component that does. This wrapper reacts to changes and updates the component
within. This forces an update on the component, which in turn causes a call to <code>render</code> to refresh the view. The change cascades down to <code>TodoList</code> and to the
individual Todo that was originally clicked.</p>
<p>But as we mentioned before, there was another component interested in changes to the Todos. This is the main menu item for Todo, which shows the number of open
Todos.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> todoCount = props.proxy().getOrElse(<span class="hljs-number">0</span>)
<span class="hljs-type">Seq</span>(
  &lt;.span(<span class="hljs-string">&quot;Todo &quot;</span>),
  &lt;.span(bss.labelOpt(<span class="hljs-type">CommonStyle</span>.danger), bss.labelAsBadge, todoCount).when(todoCount &gt; <span class="hljs-number">0</span>)
)
</code></pre>
<p>This is the beauty of unidirectional data flow, where the components do not need to know where the change came from, or who might be
interested in the change. All state changes are propagated to interested parties automatically.</p>
<p>Next, let&apos;s look how to set up everything for data to flow.</p>
<h2 id="wiring">Wiring</h2>
<p><strong>RootModel</strong></p>
<ul>
<li>Represents application model, including todos and motd</li>
</ul>
<p><strong>SPACircuit</strong></p>
<ul>
<li>Singleton instance of Diode <code>Circuit[RootModel]</code>, holding application model and action handlers.</li>
<li>Also extends <code>ReactConnector[RootModel]</code>, providing integration to React components</li>
</ul>
<p><strong>TodoHandler</strong></p>
<ul>
<li>Handles actions related to the todos.</li>
</ul>
<p><strong>MotdHandler</strong></p>
<ul>
<li>Handles actions related to Motd.</li>
</ul>
<p>To give our React components access to the application model, we have to <em>connect</em> them using <code>SPACircuit.connect</code> or <code>SPACircuit.wrap</code> methods.</p>
<pre><code class="lang-scala"><span class="hljs-type">SPACircuit</span>.wrap(_.motd)(proxy =&gt; <span class="hljs-type">Dashboard</span>(ctl, proxy))
<span class="hljs-type">SPACircuit</span>.connect(_.todos)(<span class="hljs-type">Todo</span>(_))
</code></pre>
<p>The difference between <code>wrap</code> and <code>connect</code> is that the former provides only passive read access to the model and the dispatcher, while the latter registers a
listener with the circuit and actively updates the wrapped component when the state changes. Both methods take a <em>reader function</em> that extracts the part of the
model we are interested in. The second parameter is a function that builds the component with a <code>ModelProxy[A]</code>. The <code>ModelProxy</code> wraps the extracted
model and provides access to the dispatcher.</p>
<p>Within <code>Dashboard</code> we further connect the <code>Motd</code> component to the model using the <code>connect</code> method of the <code>ModelProxy</code>.</p>
<pre><code class="lang-scala">proxy.connect(m =&gt; m)(<span class="hljs-type">Motd</span>(_))
</code></pre>
<p>Because <code>Dashboard</code> received only the <code>motd</code> part of the model, we pass it as such to the Motd component.</p>
<h2 id="working-with-potential-data">Working with potential data</h2>
<p>You may have noticed that instead of <code>String</code> the Motd component receives a <code>Pot[String]</code>. <code>Pot</code> is a helpful construct to handle data that can have multiple
states. It&apos;s quite much like Scala <code>Option</code> but more than two states. </p>
<p><img src="http://ochrons.github.io/diode/images/pot-states.png" alt="Pot states"></p>
<p>Viewing potential data can be cumbersome, so Diode includes a handy implicit class to extend a <code>Pot</code> into a <code>PotReact</code>. This allows you to call specific <code>render</code>
methods that only render when the <code>Pot</code> is in a specific state, making it easy to show a &quot;Loading&quot; or &quot;Error&quot; message to the user.</p>
<pre><code class="lang-scala">proxy().renderPending(_ &gt; <span class="hljs-number">500</span>, _ =&gt; &lt;.p(<span class="hljs-string">&quot;Loading...&quot;</span>)),
proxy().renderFailed(ex =&gt; &lt;.p(<span class="hljs-string">&quot;Failed to load&quot;</span>)),
proxy().render(m =&gt; &lt;.p(m)),
</code></pre>
<p><code>renderPending</code> has two variants and we are using the filtered one here. The first parameter is a filter for duration value. Only if the request has been in
pending state for more than 500ms will the &quot;Loading...&quot; message be displayed. The base <code>render</code> method renders the contents of the <code>Pot</code> if it has any.</p>
<p>You can also call the various <code>isEmpty</code>, <code>isPending</code>, <code>isFailed</code> etc. methods to query the state of the <code>Pot</code>, or use the monadic functions like <code>map</code> and 
<code>flatMap</code> to operate on them.</p>
<p>Within action handlers you can manage the <code>Pot</code> state yourself, depending on the results you receive from async functions like autowire calls. For the common
case, however, you can utilize ready-made handlers that take care of all that, providing you with automatic retries and notifications while the request is
pending.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handle</span> </span>= {
  <span class="hljs-keyword">case</span> action: <span class="hljs-type">UpdateMotd</span> =&gt;
    <span class="hljs-keyword">val</span> updateF = action.effect(<span class="hljs-type">AjaxClient</span>[<span class="hljs-type">Api</span>].welcome(<span class="hljs-string">&quot;User X&quot;</span>).call())(identity)
    action.handleWith(<span class="hljs-keyword">this</span>, updateF)(<span class="hljs-type">PotAction</span>.handler(<span class="hljs-number">3</span>))
}
</code></pre>
<p>We first create an <em>effect</em> from the async call we want to perform and then pass that on to the <code>PotAction.handler</code> to be automatically managed.</p>
<p>For more information on Diode, please refer to its <a href="https://ochrons.github.io/diode" target="_blank">documentation</a>.</p>
<h2 id="editing-todos">Editing todos</h2>
<p>For adding new Todo items, the user interface provides a button and a modal dialog box (using the <code>Modal</code> component described earlier). Editing
an existing item is performed by clicking an <em>Edit</em> button next to the todo description. Both actions open the same dialog. Finally you can also
delete a todo by clicking the <em>Delete</em> button.</p>
<p><code>TodoForm</code> is a simple React component built around a <code>Modal</code> which allows users to edit an existing Todo item, or create a new one 
(there is no difference between these two from the component&apos;s point of view). It looks like this</p>
<p><img src="images/dialogbox.png?raw=true" alt="Dialog box"></p>
<p>The dialog gets an optional item in properties and maintains current item in its state. The <code>submitHandler</code> callback is used to inform the parent
when the dialog box is closed (or cancelled).</p>
<pre><code class="lang-scala"><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Props</span>(<span class="hljs-params">item: <span class="hljs-type">Option</span>[<span class="hljs-type">TodoItem</span>], submitHandler: (<span class="hljs-type">TodoItem</span>, <span class="hljs-type">Boolean</span></span>) <span class="hljs-title">=&gt;</span> <span class="hljs-title">Unit</span>)</span>

<span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">State</span>(<span class="hljs-params">item: <span class="hljs-type">TodoItem</span>, cancelled: <span class="hljs-type">Boolean</span> = true</span>)</span>
</code></pre>
<p>Building the component looks a bit complicated, so let&apos;s walk through it.</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> component = <span class="hljs-type">ScalaComponent</span>.builder[<span class="hljs-type">Props</span>](<span class="hljs-string">&quot;TodoForm&quot;</span>)
  .initialStateFromProps(p =&gt; <span class="hljs-type">State</span>(p.item.getOrElse(<span class="hljs-type">TodoItem</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-type">TodoNormal</span>, <span class="hljs-literal">false</span>))))
  .renderBackend[<span class="hljs-type">Backend</span>]
  .build

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">render</span></span>(p: <span class="hljs-type">Props</span>, s: <span class="hljs-type">State</span>) = {
  log.debug(<span class="hljs-string">s&quot;User is <span class="hljs-subst">${if (s.item.id == &quot;&quot;) &quot;adding&quot; else &quot;editing&quot;}</span> a todo&quot;</span>)
  <span class="hljs-keyword">val</span> headerText = <span class="hljs-keyword">if</span> (s.item.id == <span class="hljs-string">&quot;&quot;</span>) <span class="hljs-string">&quot;Add new todo&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;Edit todo&quot;</span>
  <span class="hljs-type">Modal</span>(<span class="hljs-type">Modal</span>.<span class="hljs-type">Props</span>(
    <span class="hljs-comment">// header contains a cancel button (X)</span>
    header = hide =&gt; &lt;.span(&lt;.button(^.tpe := <span class="hljs-string">&quot;button&quot;</span>, bss.close, ^.onClick --&gt; hide, <span class="hljs-type">Icon</span>.close), &lt;.h4(headerText)),
    <span class="hljs-comment">// footer has the OK button that submits the form before hiding it</span>
    footer = hide =&gt; &lt;.span(<span class="hljs-type">Button</span>(<span class="hljs-type">Button</span>.<span class="hljs-type">Props</span>(submitForm() &gt;&gt; hide), <span class="hljs-string">&quot;OK&quot;</span>)),
    <span class="hljs-comment">// this is called after the modal has been hidden (animation is completed)</span>
    closed = formClosed(s, p)),
    &lt;.div(bss.formGroup,
      &lt;.label(^.`<span class="hljs-keyword">for</span>` := <span class="hljs-string">&quot;description&quot;</span>, <span class="hljs-string">&quot;Description&quot;</span>),
      &lt;.input.text(bss.formControl, ^.id := <span class="hljs-string">&quot;description&quot;</span>, ^.value := s.item.content,
        ^.placeholder := <span class="hljs-string">&quot;write description&quot;</span>, ^.onChange ==&gt; updateDescription)),
    &lt;.div(bss.formGroup,
      &lt;.label(^.`<span class="hljs-keyword">for</span>` := <span class="hljs-string">&quot;priority&quot;</span>, <span class="hljs-string">&quot;Priority&quot;</span>),
      <span class="hljs-comment">// using defaultValue = &quot;Normal&quot; instead of option/selected due to React</span>
      &lt;.select(bss.formControl, ^.id := <span class="hljs-string">&quot;priority&quot;</span>, ^.value := s.item.priority.toString, ^.onChange ==&gt; updatePriority,
        &lt;.option(^.value := <span class="hljs-type">TodoHigh</span>.toString, <span class="hljs-string">&quot;High&quot;</span>),
        &lt;.option(^.value := <span class="hljs-type">TodoNormal</span>.toString, <span class="hljs-string">&quot;Normal&quot;</span>),
        &lt;.option(^.value := <span class="hljs-type">TodoLow</span>.toString, <span class="hljs-string">&quot;Low&quot;</span>)
      )
    )
  )
}
</code></pre>
<p>State is first initialized with the provided item or with a new empty item. Within the <code>render</code> method (inside <code>Backend</code>) a new <code>Modal</code> is created and in the
properties we assign couple of button controls. Note how both <code>header</code> and <code>footer</code> are actually functions that are given to the <code>Modal</code>&apos;s <code>Backend</code> so that they
can call the <code>hide</code> function. In the OK button the form is first submitted before the dialog is hidden.</p>
<p>The form itself is quite straightforward, with handlers to update internal state as fields change. Note that with React the <code>select</code> element works a bit
differently from regular HTML5 and you must use <code>value</code> property to select the option instead of the typical <code>selected</code> attribute.</p>
<p>When the form closes, the parent&apos;s <code>submitHandler</code> gets called with the item and a flag indicating if the dialog box was cancelled.</p>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">formClosed</span></span>(state: <span class="hljs-type">State</span>, props: <span class="hljs-type">Props</span>): <span class="hljs-type">Callback</span> = {
  <span class="hljs-comment">// call parent handler with the new item and whether form was OK or cancelled</span>
  props.submitHandler(state.item, state.cancelled)
}
</code></pre>
<p>But now it&apos;s time to get to the bottom of client-server communications!</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="integrating-javascript-components.html" class="navigation navigation-prev " aria-label="Previous page: Integrating JavaScript components">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="autowire-and-boopickle.html" class="navigation navigation-next " aria-label="Next page: Autowire and BooPickle">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Todo module and data flow","level":"1.3.1.6","depth":3,"next":{"title":"Autowire and BooPickle","level":"1.3.1.7","depth":3,"path":"autowire-and-boopickle.md","ref":"autowire-and-boopickle.md","articles":[]},"previous":{"title":"Integrating JavaScript components","level":"1.3.1.5","depth":3,"path":"integrating-javascript-components.md","ref":"integrating-javascript-components.md","articles":[]},"dir":"ltr"},"config":{"plugins":[],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"language":"jp","gitbook":"*"},"file":{"path":"todo-module-and-data-flow.md","mtime":"2019-06-20T06:02:32.067Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2019-04-13T22:41:05.515Z"},"basePath":".","book":{"language":"jp"}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

